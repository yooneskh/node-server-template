interface IResActionFunction {
  (request: Request, response: Response, user?: IUser): Promise<any>
}

export interface ResourceAction {
  template?: ResourceActionTemplate | ResourceRelationActionTemplate;
  path?: string;
  method?: ResourceActionMethod;
  permission?: string;
  permissionFunction?(user?: IUser | null ): Promise<boolean>;
  permissionFunctionStrict?(user: IUser ): Promise<boolean>;
  payloadValidator?(payload: any): Promise<boolean>;
  payloadPreprocessor?(payload: any, user?: IUser): Promise<boolean | void>;
  payloadPostprocessor?(payload: any, user?: IUser): Promise<void>;
  action?: IResActionFunction;
  responsePreprocessor?(response: any, user?: IUser): Promise<void>;
  dataProvider?: IResActionFunction;
}

const actionHandler = async (request: Request, response: Response, next: Function) => {
  try {

    let user: IUser | undefined;
    const payload = request.body;
    const token = request.headers.authorization;

    const needToLoadUser = action.permission || action.permissionFunction || action.permissionFunctionStrict || action.payloadPreprocessor || action.payloadPostprocessor;

    if (needToLoadUser) {
      user = await getUserByToken(token);
    }

    if (action.permission && (!user || !user.permissions || !hasPermission(user.permissions || [], action.permission)) ) {
      throw new ForbiddenAccessError('forbidden access');
    }

    if ( action.permissionFunction && !(await action.permissionFunction(user)) ) {
      throw new ForbiddenAccessError('forbidden access');
    }

    if ( action.permissionFunctionStrict && ( !user || !(await action.permissionFunctionStrict(user)) ) ) {
      throw new ForbiddenAccessError('forbidden access');
    }

    if (action.payloadValidator && !(await action.payloadValidator(payload)) ) {
      throw new InvalidRequestError('payload validation failed');
    }

    if (action.payloadPreprocessor) {

      const shouldBypass = await action.payloadPreprocessor(payload, user);

      if (shouldBypass) {
        return console.log('bypassed action');
      }

    }

    if (action.action) {
      await action.action(request, response, user);
    }
    else if (action.dataProvider) {

      const data = await action.dataProvider(request, response, user);

      if (action.responsePreprocessor) {
        await action.responsePreprocessor(data, user)
      }

      response.json(data);

    }

    if (action.payloadPostprocessor) {
      await action.payloadPostprocessor(payload, user);
    }

  }
  catch (error) {
    next(error);
  }
};
